# Для того, чтобы продвинуть робота до конца, мы можем передвигаться только вниз и вправо
# Соответственно, мы учитываем все моменты: если вдруг у робота есть препятствие на начальной точке, возвращаем 0
# Также, просчитывая путь по столбцам и строкам, мы продвигаемся по свободным клеткам со значением 0
# Не забываем записывать кол-во способов достижения финишной точки, после чего по прохождению пути, возвращаем значение, хранящееся в нижней правой точке
# сложность O(m*n)
class Solution:
    def uniquePathsWithObstacles(obstacleGrid):
        if obstacleGrid[0][0]:                     # если в начальной ячейке препятствие
            return 0                               # возвращаем 0
        x = len(obstacleGrid)                      # вводим переменную х
        y = len(obstacleGrid[0])                   # вводим переменную у
        arr = [[0] * y for el in range(x)]         # задаём значение стартовой клетки
        arr[0][0] = 1                              # количество способов добраться до стартовой клетки = 1
        for i in range(x):                         # проходимся по строке
            for j in range(y):                     # проходимся по столбцу
                if (obstacleGrid[i][j]) or (i == 0 and j == 0):     # если значения x и y равны 0
                    continue                                        # идём дальше
                arr[i][j] = (arr[i - 1][j] if i else 0) + (arr[i][j - 1] if j else 0)     # количество способов достижения ячейки
        return arr[x - 1][y - 1]                                                          # возвращаем значение, хранящееся в самой нижней правой ячейке
